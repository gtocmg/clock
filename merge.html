<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Widgets Horloge</title>
<style>
        body {
            margin: 18px;
            padding: 0;
            background-color: #000000;
            color: #fff;
            font-family: Arial, sans-serif;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .time-widget {
            background-color: #000000;
            padding: 0;
            display: inline-block;
            pointer-events: none;
            user-select: none;
            margin: 0 12px; /* Espace entre les horloges */
        }

        #Canada_z18a, #clock {
            font-size: 24px;
            margin-top: 0px;
            line-height: 1;
            font-weight: normal;
        }

        /* Disposition des horloges côte à côte */
        .clock-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #time_is_link {
            visibility: hidden;  /* Rendre le lien invisible */
            pointer-events: none; /* Désactiver l'interaction avec le lien */
        }        
    </style>
</head>
<body>
    <div class="clock-container">
        <!-- Première horloge : Canada -->
        <div class="time-widget">
            <span id="Canada_z18a"></span>
        </div>

        <!-- Deuxième horloge : Heure NIST -->
        <div class="time-widget">
            <span id="clock">--:--:--</span>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://widget.time.is/t.js"></script>
    <script>
        // Widget Time.is pour l'heure du Canada
        function refreshWidget() {
            time_is_widget.init({Canada_z18a:{}}); 
        }
        refreshWidget();
        setInterval(refreshWidget, 10000); // Rafraîchissement toutes les 5 secondes
    </script>

    <!-- Lien caché mais non cliquable -->
    <a href="https://time.is/Canada" id="time_is_link" rel="nofollow"></a>

    <script>
        /* Code pour l'horloge NIST avec offset UTC-5 */

        const FETCH_URL = 'https://time.gov/widget/dhtml/at_nist_use_only.cgi';
        const FETCH_INTERVAL_MS = 10000;  // Toujours 10 secondes entre les appels réseau
        const RENDER_INTERVAL_MS = 250;   // boucle légère (250ms) pour coller au tick de la seconde
        const EASTERN_OFFSET_HOURS = -5;

        let serverMicro = null;
        let serverPerfMs = null;
        let lastRaw = null;

        
        let lastShown = null;
const clockEl = document.getElementById('clock');

        function pad(n, len = 2) { return String(n).padStart(len, '0'); }

        function formatHHMMSSFromMicroBig(currentMicroBig) {
            const msBig = currentMicroBig / 1000n;
            const msNumber = Number(msBig);
            const shiftedMsForUTC = msNumber + EASTERN_OFFSET_HOURS * 3600_000;
            const d = new Date(shiftedMsForUTC);
            const hh = pad(d.getUTCHours(), 2);
            const mm = pad(d.getUTCMinutes(), 2);
            const ss = pad(d.getUTCSeconds(), 2);
            return `${hh}:${mm}:${ss}`;
        }

        function render() {
            if (serverMicro === null || serverPerfMs === null) {
                if (lastShown !== '--:--:--') {
                    clockEl.textContent = '--:--:--';
                    lastShown = '--:--:--';
                }
                return;
            }
            const deltaMs = performance.now() - serverPerfMs;
            const deltaMicro = BigInt(Math.round(deltaMs * 1000));
            const currentMicro = serverMicro + deltaMicro;

            const txt = formatHHMMSSFromMicroBig(currentMicro);
            if (txt !== lastShown) {
                clockEl.textContent = txt;
                lastShown = txt;
            }
        }

        async function fetchServerTime() {
            // Mesure RTT pour corriger un peu le décalage (approx RTT/2)
            const t0 = performance.now();
            try {
                const resp = await fetch(FETCH_URL, {cache: 'no-store'});
                if (!resp.ok) throw new Error('HTTP ' + resp.status);
                const text = (await resp.text()).trim();
                lastRaw = text;
                const m = text.match(/(\d{13,})/);
                if (!m) throw new Error('Format invalide: ' + text);
                serverMicro = BigInt(m[1]);
                const t1 = performance.now();
                // Corrige d'environ la moitié du RTT
                const rttHalfMicro = BigInt(Math.round(((t1 - t0) / 2) * 1000));
                serverMicro = serverMicro + rttHalfMicro;
                serverPerfMs = t1;
                render();
            } catch (e) {
                console.warn('sync error', e);
            }
        }

        fetchServerTime();
        setInterval(fetchServerTime, FETCH_INTERVAL_MS);  // Sync réseau périodique

        // --- Render "synced" : aligne l'update sur le changement de seconde (évite d'avoir ~1s de retard) ---
        let tickTimer = null;

        function clearTick() {
            if (tickTimer) { clearTimeout(tickTimer); tickTimer = null; }
        }

        function scheduleNextTick() {
            clearTick();

            if (serverMicro === null || serverPerfMs === null) {
                tickTimer = setTimeout(scheduleNextTick, 500);
                return;
            }

            // Temps courant estimé en microsecondes
            const deltaMs = performance.now() - serverPerfMs;
            const nowMicro = serverMicro + BigInt(Math.round(deltaMs * 1000));

            // Combien de microsecondes avant la prochaine seconde exacte ?
            const remainder = nowMicro % 1000000n;
            const waitMicro = 1000000n - remainder;

            // 1) On se réveille un peu AVANT le tick (pour compenser le jitter des timers)
            //    35-50ms est un bon compromis (CPU quasi nul).
            let waitMs = Number(waitMicro / 1000n) - 40;
            if (waitMs < 0) waitMs = 0;

            tickTimer = setTimeout(() => {
                // 2) Phase "chase": on utilise rAF pendant une très courte fenêtre
                //    pour détecter précisément le changement de seconde sans tourner en boucle 60fps toute la journée.
                const start = performance.now();
                let lastSec = null;

                const step = () => {
                    // Recalcule le temps courant
                    const dMs = performance.now() - serverPerfMs;
                    const curMicro = serverMicro + BigInt(Math.round(dMs * 1000));
                    const sec = curMicro / 1000000n; // seconde entière (BigInt)

                    if (lastSec === null) lastSec = sec;

                    // Dès que la seconde a changé: render et on reschedule
                    if (sec !== lastSec) {
                        render();
                        scheduleNextTick();
                        return;
                    }

                    // Timeout de sécurité (évite de rester coincé si tab throttled)
                    if (performance.now() - start > 140) {
                        render();
                        scheduleNextTick();
                        return;
                    }

                    requestAnimationFrame(step);
                };

                requestAnimationFrame(step);
            }, waitMs);
        }

        // Aussi, on fait un render léger toutes les 250ms, mais le DOM ne bouge que si la seconde change
        // (ça aide à réduire l'effet "lag" si le navigateur throttle les timers)
        setInterval(render, RENDER_INTERVAL_MS);

        scheduleNextTick();// (Optionnel) Évite du travail inutile quand l'onglet est en arrière-plan
        document.addEventListener('visibilitychange', () => {
            // Rien de spécial à faire: le render est déjà léger (1Hz),
            // mais tu peux stopper/relancer les intervals ici si tu veux.
        });  // Rafraîchissement visuel toutes les 200ms (5 fois par seconde)
</script>
</body>
</html>
