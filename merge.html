<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Widgets Horloge</title>
<style>
        body {
            margin: 18px;
            padding: 0;
            background-color: #000000;
            color: #fff;
            font-family: Arial, sans-serif;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .time-widget {
            background-color: #000000;
            padding: 0;
            display: inline-block;
            pointer-events: none;
            user-select: none;
            margin: 0 12px; /* Espace entre les horloges */
        }

        #Canada_z18a, #clock {
            font-size: 24px;
            margin-top: 0px;
            line-height: 1;
            font-weight: normal;
        }

        /* Disposition des horloges côte à côte */
        .clock-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #time_is_link {
            visibility: hidden;  /* Rendre le lien invisible */
            pointer-events: none; /* Désactiver l'interaction avec le lien */
        }        
    </style>
</head>
<body>
    <div class="clock-container">
        <!-- Première horloge : Canada -->
        <div class="time-widget">
            <span id="Canada_z18a"></span>
        </div>

        <!-- Deuxième horloge : Heure NIST -->
        <div class="time-widget">
            <span id="clock">--:--:--</span>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://widget.time.is/t.js"></script>
    <script>
        // Widget Time.is pour l'heure du Canada
        function refreshWidget() {
            time_is_widget.init({Canada_z18a:{}}); 
        }
        refreshWidget();
        setInterval(refreshWidget, 5000); // Rafraîchissement toutes les 5 secondes
    </script>

    <!-- Lien caché mais non cliquable -->
    <a href="https://time.is/Canada" id="time_is_link" rel="nofollow"></a>

    <script>
        /* Horloge NIST (time.gov) — légère + tick aligné (réduit le délai visuel) */

        const FETCH_URL = 'https://time.gov/widget/dhtml/at_nist_use_only.cgi';
        const FETCH_INTERVAL_MS = 10000;  // réseau: 10s
        const RENDER_FALLBACK_MS = 250;   // boucle légère (le DOM ne change que si la seconde change)
        const EASTERN_OFFSET_HOURS = -5;

        let serverMicro = null;  // microsecondes (BigInt)
        let serverPerfMs = null; // perf.now() au moment de référence
        let lastShown = null;

        const clockEl = document.getElementById('clock');

        function pad(n, len = 2) { return String(n).padStart(len, '0'); }

        function formatHHMMSSFromMicroBig(currentMicroBig) {
            // microseconds -> ms
            const ms = Number(currentMicroBig / 1000n);
            const d = new Date(ms);

            // Conserver le comportement original (offset fixe -5)
            const utc = d.getTime() + (d.getTimezoneOffset() * 60000);
            const eastern = new Date(utc + (EASTERN_OFFSET_HOURS * 3600000));

            return `${pad(eastern.getHours())}:${pad(eastern.getMinutes())}:${pad(eastern.getSeconds())}`;
        }

        function render() {
            if (serverMicro === null || serverPerfMs === null) {
                if (lastShown !== '--:--:--') {
                    clockEl.textContent = '--:--:--';
                    lastShown = '--:--:--';
                }
                return;
            }

            const deltaMs = performance.now() - serverPerfMs;
            const currentMicro = serverMicro + BigInt(Math.round(deltaMs * 1000));

            const txt = formatHHMMSSFromMicroBig(currentMicro);
            if (txt !== lastShown) {
                clockEl.textContent = txt;
                lastShown = txt;
            }
        }

        async function fetchServerTime() {
            // RTT/2 correction simple pour réduire l'offset
            const t0 = performance.now();
            try {
                const resp = await fetch(FETCH_URL, { cache: 'no-store' });
                if (!resp.ok) throw new Error('HTTP ' + resp.status);
                const text = (await resp.text()).trim();

                const m = text.match(/(\d{13,})/);
                if (!m) throw new Error('Format invalide: ' + text);

                let micro = BigInt(m[1]);
                const t1 = performance.now();

                const rttHalfMicro = BigInt(Math.round(((t1 - t0) / 2) * 1000));
                micro = micro + rttHalfMicro;

                serverMicro = micro;
                serverPerfMs = t1;

                render();
            } catch (e) {
                console.warn('NIST sync error', e);
            }
        }

        // --- Tick aligné ---
        let tickTimer = null;

        function clearTick() {
            if (tickTimer) { clearTimeout(tickTimer); tickTimer = null; }
        }

        function scheduleNextTick() {
            clearTick();

            if (serverMicro === null || serverPerfMs === null) {
                tickTimer = setTimeout(scheduleNextTick, 300);
                return;
            }

            const deltaMs = performance.now() - serverPerfMs;
            const nowMicro = serverMicro + BigInt(Math.round(deltaMs * 1000));

            const remainder = nowMicro % 1000000n;
            const waitMicro = 1000000n - remainder;

            // Réveille ~40ms avant le tick pour compenser le jitter
            let waitMs = Number(waitMicro / 1000n) - 40;
            if (waitMs < 0) waitMs = 0;

            tickTimer = setTimeout(() => {
                const start = performance.now();
                let lastSec = null;

                const step = () => {
                    const dMs = performance.now() - serverPerfMs;
                    const curMicro = serverMicro + BigInt(Math.round(dMs * 1000));
                    const sec = curMicro / 1000000n;

                    if (lastSec === null) lastSec = sec;

                    if (sec !== lastSec) {
                        render();
                        scheduleNextTick();
                        return;
                    }

                    if (performance.now() - start > 140) {
                        render();
                        scheduleNextTick();
                        return;
                    }

                    requestAnimationFrame(step);
                };

                requestAnimationFrame(step);
            }, waitMs);
        }

        // Bootstrap immédiat: pas de "délai au début"
        serverMicro = BigInt(Date.now()) * 1000n;
        serverPerfMs = performance.now();
        render();

        // Warmup: 3 syncs rapides au démarrage pour réduire l'offset initial
        (async () => {
            try {
                await fetchServerTime();
                await new Promise(r => setTimeout(r, 250));
                await fetchServerTime();
                await new Promise(r => setTimeout(r, 250));
                await fetchServerTime();
            } catch (e) {
                console.warn('warmup error', e);
            }
        })();

        setInterval(fetchServerTime, FETCH_INTERVAL_MS);
        setInterval(render, RENDER_FALLBACK_MS); // léger: le DOM change max 1x/sec

        scheduleNextTick();
    </script>
</body>
</html>
